#define Hitsmap_cxx
#include <TStyle.h>
#include <sstream>
#include <string.h>
#include <vector>
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <utility>
#include <stdio.h>
#include <TCanvas.h>
#include <TSpectrum.h>
#include "TFile.h"
#include <TF1.h>
#include "TInterpreter.h"
#include <TStyle.h>
#include "TTree.h"
#include "TMath.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TGraph.h"
#include "TSpectrum.h"
#include "Hitsmap.h"
using namespace std;
using namespace RICHsystem;
class RootConvert;

void RootConvert::Loop2(TTree *signaltree, TTree *bkgtree){}

void RootConvert::Loop(char *RootFileName)
{
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //IO stream
  string namesuffix="_hitsmap";
  string outputfile=(string)RootFileName;
  outputfile.replace(strlen(RootFileName)-5,5,namesuffix);
  int Lname=sizeof(outputfile.c_str());
  string out;
  out.assign(outputfile,11,Lname-11);
  string EPSFile="./Hitsmap/"+out+".eps";
  string RFile="./Hitsmap/"+out+".root";
  
  cout<<"Output files:"<<endl;
  cout<<"Histogram pictures: "<<EPSFile<<endl;
  cout<<"Histogram root: "<<RFile<<"\n"<<endl;

  TFile *outFile=new TFile(RFile.c_str(),"RECREATE");
  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //IMPORTANT CHANGE: in this test(Fe55,TPC mm,version2), 1 fec(no.31) is used, for this fec, 4 chips(no.0-4) are used, for each chip 68 channels are used(no.0-67,4 of them are noise channels)
  //define the TH1F for pedestal 
//  const int Nsp=512;
//  const int Nch=68;
//  const int Nfec=2;
//  const int Nchip=4; //per FEC 
  char pedestaldata[80] ="./Calibration/noise_03_16_10pC.txt";           //Notice:This pedestal file is NOT the txt file generated by Pedestal.C. It should be generated by other ways
  LoadPedestal(pedestaldata);                             //*****************
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //define the TH1F for hitsmap
  //TH1F *effhits_hist= new TH1F("effhits",";ADC;counts",4200,-100,4100);
  //TH1F *peakingtime= new TH1F("peakingtime",";SamplingPoint;counts",300,50,350);
  //TH2F *hitsmap;
  //TH2F *effhitsmap= new TH2F("effhitsmap",";X(5mm);Y(5mm)",31,0,31,31,0,31);
  ////TH2F *hitmap =new TH2F(histitle,";X(5mm);Y(5mm)",33,0,33,33,0,33);
  //TGraph *waveform= new TGraph();
    
  //IMPORTANT CHANGE: new graphs defined
    //TGraph* waveform = new TGraph();                //ADC wave graph. 1 graph/channel
    TGraph* energy_lost_x = new TGraph();               //energy lost graph on x channels. 1 graph/event
    TGraph* energy_lost_y = new TGraph();               //energy lost graph on y channels. 1 graph/event
    TGraph* peakingtime_x = new TGraph();               //peaking time graph on x channels. 1 graph/event
    TGraph* peakingtime_y = new TGraph();               //peaking time graph on y channels. 1 graph/event

    TH1F* spectrum = new TH1F("Energy_Spectrum", "Energy spectrum;ADC channel;counts", 1000, 0, 40000);      //energy spectrum. 1 graph in total
    TH1F* spectrum_central = new TH1F("spectrum_central","Central region spectrum;ADC channel;counts",1000,0,40000);    //energy spectrum in central region
    TH1F* spectrum1 = new TH1F("Energy_Spectrum_1", ";summaxADC;counts", 1000, 0, 20000);       //ONLY used in charge distribution test, first version of spectrum
    TH1F* spectrum2 = new TH1F("Energy_Spectrum_2", ";summaxADC;counts", 1000, 0, 20000);       //ONLY used in charge distribution test, second version of spectrum
    TH2F *energy_vs_hits = new TH2F("energy_vs_track_length","Energy v.s. Track length;Track length;energy",50,0,50,100,0,40000);
    TH1F *effhits_hist= new TH1F("total_hits","Total hits number;Total hits;counts",40,0,80);     //efficient hits per event
    TH1F *xhits_hist = new TH1F("xhits", "Hit number in X;xhits;counts",20,0,20);            //x hits per event
    TH1F *yhits_hist = new TH1F("yhits", "Hit number in Y;yhits;counts",20,0,20);            //y hits per event
    TH1F *peakingtime_diff = new TH1F("transit_time","Transit time;time point;counts",200,0,500);       //diff between max and min peaking time
    TH2F* effhitsmap = new TH2F("hitsmap","Track start position;X;Y",96,0,96.,96,0,96.);       //2D hits map
    TH1F *max_energy_lost_pos = new TH1F("max_energy_lost_pos","Max energy lost position;Max energy lost position;counts",40,0,1);
    TH2F* energy_vs_angle = new TH2F("energy_vs_angle","Energy v.s. Cot(theta);Cot(theta);energy",50,0,3,100,0,40000);
    TH2F* energy_vs_angle_corrected = new TH2F("energy_vs_angle(corrected)","Energy v.s. Cot(theta);Cot(theta);energy",50,0,3,100,0,40000);
    TH1F* spectrum_corrected = new TH1F("Energy_Spectrum_corrected","Energy Spectrum(corrected);ADC channels(corrected);counts",1000,0,40000);

    TF1* gaus1 = new TF1("gaus1", "gaus(0)", 8000, 20000);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ////mapL2 fec to connector Number
  //std::map <Int_t,Int_t> fecNo;                             //***********
  //fecNo.insert(pair<Int_t,Int_t>(5,0));//fec 1: hirose 0,1 
  //fecNo.insert(pair<Int_t,Int_t>(2,1));//fec 5: hirose 6,7
  //fecNo.insert(pair<Int_t,Int_t>(7,2));//fec 2: hirose 2,3
  //fecNo.insert(pair<Int_t,Int_t>(10,3));//fec 4: hirose 4,5
          
  //new mapL2
  std::map <Int_t, Int_t> mapL2;
  mapL2.insert(pair<Int_t, Int_t>(31, 0));                    //fec 31--->tag 0
  mapL2.insert(pair<Int_t, Int_t>(15, 1));                    //fec 15--->tag 1
  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //Loop start
  cout<<"Loop Root File..."<<endl;
  if (fChain == 0) return;
  Long64_t nentries = fChain->GetEntriesFast();
  cout<<"~~~~~~~~~~~~~~~"<<endl;
  cout<<"Nentries:"<<nentries<<endl;
  Long64_t ientry;
  
  int effhit=0; 
  double pedS,pedM;
  char grtitle[100];
  int x_count, y_count;

  double sumA[2];             //sum(maxADC) of x, y
  double sumAP[2];            //sum(maxADC*channel position) of x, y
  double start_pos[2];              //x, y position reconstructed
  Float_t x_timerange[4], y_timerange[4];
  //x_timerange[0]:the x coordinate of min time point in x strip graph
  //x_timerange[1]:the y coordinate of min time point in x strip graph
  //x_timerange[2]:the x coordinate of max time point in x strip graph
  //x_timerange[3]:the y coordinate of max time point in x strip graph
  Float_t x_range[4], y_range[4];        
  //x_range[0]:the minimum hit channel of x strip graph
  //x_range[1]:the peaking time at the minimum hit channel of x strip graph
  //x_range[2]:the maximum hit channel of x strip graph
  //x_range[3]:the peaking time at the maximum hit channel of x strip graph
  Float_t x_Emax[2], y_Emax[2];               
  //x_Emax[0]:the x coordinate of max energy lost point in x strip graph
  //x_Emax[1]:the y coordinate of max energy lost point in x strip graph
  Float_t timerange[2]; 
  Float_t time_of_Emax_x, time_of_Emax_y; 
  Double_t sqrt_hit; 
  
  Float_t summaxADC1, summaxADC2;     //FOR charge distribution test

  Double_t source[Nsp];         //save the current waveform
  Double_t dest[Nsp];           //save the analysed output waveform
  Int_t nfound;                 //number of peaks found
  TSpectrum *s = new TSpectrum();
  Double_t xpeaks[100];          //peak x position 
  Float_t ypeaks[100];          //peak y position
  Float_t summax_new;             //define a new variable to calculate the total energy deposition

  Bool_t Is_small_range = true;     //flag if the range is small/big
  Bool_t MultiPeak = false;         //flag if use peak finding method

  Double_t Cot_theta = 0;            //A number proportional to cotangent of the inlet angle, used for energy correction

  for(int loop=0;loop<2;loop++){//A single loop for hitsmap one event
    for (Long64_t jentry=0; jentry<nentries;jentry++){
        ientry = LoadTree(jentry);
        if (ientry < 0) break;
        fChain->GetEntry(jentry);
        //loop entries
        if(jentry%((int)(nentries/10.))==0){
            // cout<<"Events:"<<jentry<<"("<<(int)(jentry*100./nentries)<<"%)"<<endl;
            cout<<"Events:"<<jentry<<endl;
        }
        ////reset;

        memset(sumA,0,sizeof(sumA));
        memset(sumAP,0,sizeof(sumAP));
        memset(start_pos,0,sizeof(start_pos));

        effhit=0;
        //memset(histitle,0,sizeof(histitle));
        //sprintf(histitle,"Event_%d_hitmap",event);
        //hitsmap =new TH2F(histitle,";X(5mm);Y(5mm)",33,0,33,33,0,33);      //*****
        ////  std::cout<<"nHits ="<<nHits<<std::endl;
        
        //reset the parameters of 4 graphs
        energy_lost_x->SetMarkerStyle(7);
        memset(grtitle, 0, sizeof(grtitle));
        sprintf(grtitle, "Event%d_Energy_Lost_X", event);
        energy_lost_x->SetTitle(grtitle);
        energy_lost_x->SetName(grtitle);

        energy_lost_y->SetMarkerStyle(7);
        memset(grtitle, 0, sizeof(grtitle));
        sprintf(grtitle, "Event%d_Energy_Lost_Y", event);
        energy_lost_y->SetTitle(grtitle);
        energy_lost_y->SetName(grtitle);

        peakingtime_x->SetMarkerStyle(7);
        memset(grtitle, 0, sizeof(grtitle));
        sprintf(grtitle, "Event%d_Track_X", event);
        peakingtime_x->SetTitle(grtitle);
        peakingtime_x->SetName(grtitle);

        peakingtime_y->SetMarkerStyle(7);
        memset(grtitle, 0, sizeof(grtitle));
        sprintf(grtitle, "Event%d_Track_Y", event);
        peakingtime_y->SetTitle(grtitle);
        peakingtime_y->SetName(grtitle);

        energy_lost_x->Set(0);
        energy_lost_y->Set(0);
        peakingtime_x->Set(0);
        peakingtime_y->Set(0);
        
        x_count = 0;            //to count the x hits number in an event
        y_count = 0;            //to count the y hits number in an event

        memset(x_timerange, 0, sizeof(x_timerange));
        memset(y_timerange, 0, sizeof(y_timerange));
        memset(x_range, 0, sizeof(x_range));
        memset(y_range, 0, sizeof(y_range));
        memset(x_Emax, 0, sizeof(x_Emax));
        memset(y_Emax, 0, sizeof(y_Emax));

        summaxADC1 = 0;
        summaxADC2 = 0;

        memset(source, 0, sizeof(source));
        memset(dest, 0, sizeof(dest));
        nfound = 0;
        memset(ypeaks, 0, sizeof(ypeaks));
        summax_new = 0;

        //fill 
        for(int i=0; i<nHits;i++){                     //********

            pedM= pedestal[mapL2[Fec[i]]][Chip[i]][Chn[i]][0];                    //mean is the 4th column of pedestal file
            pedS= pedestal[mapL2[Fec[i]]][Chip[i]][Chn[i]][1];                    //siga is the 5th column of pedestal file

            sumADC[i]=sumADC[i]-pedM*Nsp;
            maxADC[i]=maxADC[i]-pedM;
              
            //if(maxADC[i] < 50*pedS)  continue;

            // if (Chn[i] == 0 || Chn[i] == 67) continue;              //wrong signal in these two channals
            // if (pixelX[i]==0 && pixelY[i]==0) continue;                 //not a signal channel
            // if(maxPoint[i]>140||maxPoint[i]<100) continue;          //peaking time

            if((Chip[i]==2||Chip[i]==0) && Chn[i]==67)  continue;


            if(MultiPeak == false){
              //Note: the below part convert the ADC paeks into  collected charge(in pC)
                if(Is_small_range == true){
                  summax_new += maxADC[i];       //if necessary, this can be converted to charge(as below)
                }
                else{
                  // summax_new += 0.009194557*maxADC[i];     //unit of charge is pC
                  if(maxADC[i]<105)  summax_new += 0.0206*maxADC[i];
                  else if(maxADC[i]<330) summax_new += 0.008*maxADC[i]+1.421;
                  else  summax_new += 0.0069*maxADC[i]+1.423;
                }
            }
            else{
              //for peak finding, save the current waveform into an array
              for(int k = 0; k < Nsp; k++){
                source[k] = ADC[i][k];
              }   

              nfound = s->SearchHighRes(source, dest, Nsp, 6, 30, kTRUE, 3, kTRUE, 3);
              Double_t *x_peaks = s->GetPositionX();         //get the position of the found peaks
            

            // if (Chn[i] == 0 || Chn[i] == 67) continue;              //wrong signal in these two channals
            // if (pixelX[i]==0 && pixelY[i]==0) continue;                 //not a signal channel
            // if(maxPoint[i]>140||maxPoint[i]<100) continue;          //peaking time
            
              for(int k = 0; k < nfound; k++){
                xpeaks[k] = *(x_peaks+k);
                ypeaks[k] = ADC[i][(int)xpeaks[k]] - pedM;      //get the y position of found peak
                //summax_new += ypeaks[k];

                //Note: the below part convert the ADC paeks into  collected charge(in pC)
                if(Is_small_range == true){
                  summax_new += ypeaks[k];       //if necessary, this can be converted to charge(as below)
                }
                else{
                  summax_new += 0.009194557*ypeaks[k];     //unit of charge is pC
                }
              } 
            }

            //fill the 4 graphs
            if (pixelX[i]!=0) {                         //this is an x hit
                if(MultiPeak == false){
                  energy_lost_x->SetPoint(x_count, pixelX[i], maxADC[i]);
                  peakingtime_x->SetPoint(x_count, pixelX[i], maxPoint[i]);

                  x_count++;
                  effhit++;

                  //for alpha test
                  if(maxPoint[i]<x_timerange[1]||x_timerange[1]==0){
                    x_timerange[0] = pixelX[i];
                    x_timerange[1] = maxPoint[i];}
                  if(maxPoint[i]>x_timerange[3]){
                    x_timerange[2] = pixelX[i];
                    x_timerange[3] = maxPoint[i];}
                  
                  if(maxADC[i]>x_Emax[1]){
                    x_Emax[0] = pixelX[i];
                    x_Emax[1] = maxADC[i];
                    time_of_Emax_x = maxPoint[i];
                  }
                  
                  //for start position reconstruction(beta particularly)
                  if(pixelX[i]<=x_range[0]||x_range[0]==0){
                    x_range[0] = pixelX[i];
                    x_range[1] = maxPoint[i];
                  }
                  if(pixelX[i]>=x_range[2]){
                    x_range[2] = pixelX[i];
                    x_range[3] = maxPoint[i];
                  }
                  
                }
                else{
                  for(int k = 0; k < nfound; k++){
                  //if(ypeaks[k]<3*pedS)  continue;       //Possibly a noise "signal"
                  energy_lost_x->SetPoint(x_count, pixelX[i], ypeaks[k]);
                  peakingtime_x->SetPoint(x_count, pixelX[i], xpeaks[k]);
                  
                  x_count++;
                  effhit++;

                  //for alpha test
                  if(xpeaks[k]<x_timerange[1]||x_timerange[1]==0){
                    x_timerange[0] = pixelX[i];
                    x_timerange[1] = xpeaks[k];}
                  if(xpeaks[k]>x_timerange[3]){
                    x_timerange[2] = pixelX[i];
                    x_timerange[3] = xpeaks[k];}
                  
                  //for start position reconstruction(beta particularly)
                  if(pixelX[i]<=x_range[0]||x_range[0]==0){
                    x_range[0] = pixelX[i];
                    if(x_range[1]<=xpeaks[k]) x_range[1]=xpeaks[k];
                  }
                  if(pixelX[i]>=x_range[2]){
                    x_range[2] = pixelX[i];
                    if(x_range[3]<=xpeaks[k]) x_range[3]=xpeaks[k];
                  }
                  }
                }  
            }
            else if (pixelY[i]!=0) {                    //this is a y hit
                if(MultiPeak == false){
                  energy_lost_y->SetPoint(y_count, pixelY[i], maxADC[i]);
                  peakingtime_y->SetPoint(y_count, pixelY[i], maxPoint[i]);
                  
                  y_count++;
                  effhit++;

                  //for alpha test
                  if(maxPoint[i]<y_timerange[1]||y_timerange[1]==0){
                    y_timerange[0] = pixelY[i];
                    y_timerange[1] = maxPoint[i];}
                  if(maxPoint[i]>y_timerange[3]){
                    y_timerange[2] = pixelY[i];
                    y_timerange[3] = maxPoint[i];}

                  if(maxADC[i]>y_Emax[1]){
                    y_Emax[0] = pixelY[i];
                    y_Emax[1] = maxADC[i];
                    time_of_Emax_y = maxPoint[i];
                  }

                  //for start position reconstruction(beta particularly)
                  if(pixelY[i]<=y_range[0]||y_range[0]==0){
                    y_range[0] = pixelY[i];
                    y_range[1] = maxPoint[i];
                  }
                  if(pixelY[i]>=y_range[2]){
                    y_range[2] = pixelY[i];
                    y_range[3] = maxPoint[i];
                  }
                }
                else{
                  for(int k = 0; k < nfound; k++){
                  //if(ypeaks[k]<3*pedS)  continue;       //Possibly a noise "signal"
                  energy_lost_y->SetPoint(y_count, pixelY[i], ypeaks[k]);
                  peakingtime_y->SetPoint(y_count, pixelY[i], xpeaks[k]);
                  y_count++;
                  effhit++;
                  
                  //for alpha test
                  if(xpeaks[k]<y_timerange[1]||y_timerange[1]==0){
                    y_timerange[0] = pixelY[i];
                    y_timerange[1] = xpeaks[k];}
                  if(xpeaks[k]>y_timerange[3]){
                    y_timerange[2] = pixelY[i];
                    y_timerange[3] = xpeaks[k];}
                  
                  //for start position reconstruction(beta particularly)
                  if(pixelY[i]<=y_range[0]||y_range[0]==0){
                    y_range[0] = pixelY[i];
                    if(y_range[1]<=xpeaks[k])  y_range[1]=xpeaks[k];
                  }
                  if(pixelY[i]>=y_range[2]){
                    y_range[2] = pixelY[i];
                    if(y_range[3]<=xpeaks[k]) y_range[3]=xpeaks[k];
                  }
                  }
                }
            }
            else{             //this signal is NOT from a detector channel, drop it
                continue;
            }

            //ONLY for charge distribution test, fill the two spectrums
            if(pixelX[i]!=0||pixelY[i]!=0){
              if(Chip[i]==0||Chip[i]==1){
                summaxADC1 = summaxADC1+maxADC[i];
              }
              else{
                summaxADC2 = summaxADC2+maxADC[i];
              }
            }

        }//single event 

        if(x_count==0 || y_count==0)  continue;

        if(x_Emax[1]>3600||y_Emax[1]>3600)  continue;       //cut out the out-of-range events

        sqrt_hit = TMath::Sqrt(x_count*x_count+y_count*y_count);

        if(x_count==0){
          timerange[0]=y_timerange[1];
          timerange[1]=y_timerange[3];
        }
        else if(y_count==0){
          timerange[0]=x_timerange[1];
          timerange[1]=x_timerange[3];
        }
        else{
          if(x_timerange[1]<y_timerange[1]) timerange[0]=x_timerange[1];
          else  timerange[0]=y_timerange[1];
          if(x_timerange[3]>y_timerange[3]) timerange[1]=x_timerange[3];
          else  timerange[1]=y_timerange[3];
        }

        Cot_theta = (timerange[1]-timerange[0])/sqrt_hit;       // calculate the "cotangent theta"

        // //Charge mass center method for position reconstruction, ONLY for Fe55 test
        // //fill the hitsmap and central region spectrum
        // if(sumA[0]*sumA[1]!=0){
        //   for(int d=0;d<2;d++){
        //     start_pos[d] = sumAP[d]/sumA[d];        //position reconstructionn
        //   }
        //   //std::cout<<"posX ="<<start_pos[0]<<"; posY ="<<start_pos[1]<<std::endl;
        // }
        // else continue;

        //start position reconstruction for alpha
        start_pos[0] = x_timerange[2];
        start_pos[1] = y_timerange[2];

        //start position reconstruction for beta
        // if(x_range[1]>x_range[3]) start_pos[0] = x_range[0];
        // else  start_pos[0] = x_range[2];
        // if(y_range[1]>y_range[3]) start_pos[1] = y_range[0];
        // else  start_pos[1] = y_range[2];

        if(loop==1){        //fill the calibrated histogram
          //Int_t xbin = energy_vs_angle->FindBin(Cot_theta);
          Int_t xbin = (Int_t)(Cot_theta/0.06 + 1);
          energy_vs_angle->GetXaxis()->SetRange(xbin, xbin);
          Double_t mean1 = energy_vs_angle->GetMean(2);
          summax_new = summax_new - mean1 + spectrum->GetBinCenter(spectrum->GetMaximumBin());
          //cout<<"xbin: "<< xbin << " mean1: "<< mean1 << endl;
          energy_vs_angle_corrected->Fill(Cot_theta, summax_new);
          spectrum_corrected->Fill(summax_new);
          continue;
        }


        if(x_Emax[1]>y_Emax[1]){        //means the max energy lost is on x strip
          max_energy_lost_pos->Fill((timerange[1]-time_of_Emax_x)/(timerange[1]-timerange[0]));
        }
        else{               //means the max energy lost is on y strip
          max_energy_lost_pos->Fill((timerange[1]-time_of_Emax_y)/(timerange[1]-timerange[0]));
        }

        effhits_hist->Fill(effhit);         //fill the efficient hit hist
        xhits_hist->Fill(x_count);
        yhits_hist->Fill(y_count);
        spectrum->Fill(summax_new);          //Fill the spectrum with this event
        
        //ONLY for charge distribution test
        if(summaxADC1!=0) {
          spectrum1->Fill(summaxADC1);
          spectrum2->Fill(summaxADC2);
        }

        energy_vs_hits->Fill(sqrt_hit, summax_new);
        peakingtime_diff->Fill(timerange[1]-timerange[0]);

        effhitsmap->Fill(start_pos[0],start_pos[1]);
				if(start_pos[0]>36&&start_pos[0]<60&&start_pos[1]>36&&start_pos[1]<60){
          spectrum_central->Fill(summax_new);
        }
        energy_vs_angle->Fill(Cot_theta, summax_new);


        //--------------------------Alpha Cuts--------------------
        
        
        
        //--------------------------------------------------------
        
        //--------------------------Beta Cuts---------------------


        //--------------------------------------------------------

        //Write and reset the 4 graphs of this event
        if(effhit>2 && jentry<100){
            //  if(event<100&&nHitsUp>3)
            energy_lost_x->Write();
            energy_lost_y->Write();
            peakingtime_x->Write();
            peakingtime_y->Write();
        }

    }//loop end 
    }
    

    //write the hits histogram, spectrum histogram, hitsmap
    effhits_hist->Write();
    xhits_hist->Write();
    yhits_hist->Write();
    spectrum->Fit("gaus1","R");
    spectrum->Write();
    peakingtime_diff->Write();
    energy_vs_hits->Write();
    max_energy_lost_pos->Write();

    //spectrum_central->Fit("gaus1","R");
    spectrum_central->Write();
    spectrum1->Write();
    spectrum2->Write();
    effhitsmap->Write();
    energy_vs_angle->GetXaxis()->SetRange(0,0);
    energy_vs_angle->Write();
    energy_vs_angle_corrected->Write();
    spectrum_corrected->Fit("gaus1","R");
    spectrum_corrected->Write();


    //effhits_hist->Write();
    //peakingtime->Write();
    //effhitsmap->Write();
    outFile->Close();
    
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
}

//define main()
string filename;
void helpinfo(){

  cout<<"Usage is ./Hitsmap.exe ./Raw2ROOT/<filename>\n";
  cout<<"default output file name is <inputfilename.eps>"<<endl;	
  return;
} 
void phrase_command(int argc,char *argv[]){
  if (argc<2){ helpinfo();
    exit(0);
  }else {filename=(string) argv[1]; cout<<"START\n~~~~~*****~~~~~\nInput File : "<<filename<<endl;}
}

int main(int argc,char *argv[])
{

  phrase_command(argc,argv);
  string Tt="richraw";
  const char *TtreeName=(char *)(Tt.data());
  const Text_t* RawRootFile=(Text_t*)(filename.data());
  char *RawRootFile_c=(char *)(filename.data());
  TFile *f = (TFile*)gROOT->GetListOfFiles()->FindObject(RawRootFile);
  if (!f) 
    {
      f = new TFile(RawRootFile_c);
     }
  TTree *tree = (TTree*)gDirectory->Get(TtreeName);
 
  RootConvert xx;
  xx.RootConvert::Init(tree);
  xx.RootConvert::Loop(RawRootFile_c);
    cout<<"\n~~~~~*****~~~~~\nTHE END"<<endl;
  return 1;

} 

