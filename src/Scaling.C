#define Scaling_cxx
#include <TStyle.h>
#include <sstream>
#include <string.h>
#include <vector>
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <fstream>
#include <utility>
#include <stdio.h>
#include <TCanvas.h>
#include <TSpectrum.h>
#include "TFile.h"
#include <TF1.h>
#include "TInterpreter.h"
#include <TStyle.h>
#include "TTree.h"
#include "TMath.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TGraph.h"
#include "Scaling.h"
using namespace std;
using namespace RICHsystem;
class RootConvert;

void RootConvert::Loop2(TTree *signaltree, TTree *bkgtree, double threshold){}
void RootConvert::Loop3(char *RootFileName, double threshold){}

void RootConvert::Loop(char *RootFileName)
{
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //IO stream
  string namesuffix="_scaling";
  string outputfile=(string)RootFileName;
  outputfile.replace(19,strlen(RootFileName)-19,namesuffix);
  int Lname=sizeof(outputfile.c_str());
  string out;
  out.assign(outputfile,11,Lname-11);
  string TXTFile="./Scaling/"+out+".txt";           //File name format like this: 20220307_scaling.txt
  string RFile="./Scaling/"+out+".root";            //File name format like this: 20220307_scaling.root
  
  cout<<"Output files:"<<endl;
  cout<<"Scaling factors (keV/ADC channel): "<<TXTFile<<endl;
  cout<<"Histogram root: "<<RFile<<"\n"<<endl;

    //Accumulate the different data files to increase statastic numbers
  TFile *outFile=new TFile(RFile.c_str(),"UPDATE");
  ofstream outtxt;
  outtxt.open(TXTFile.c_str());

    //number of effective x, y strips is both 96
  const int strip_num = 96;

    TH1F *scaling_hist[strip_num][strip_num];

    for (int x=0;x < strip_num;x++){                         //create and name the histograms of each channel by its fec, chip and channel
      for (int y=0;y < strip_num;y++){
        char cc[60];
        memset(cc,0,sizeof(cc));
        sprintf(cc ,"Position:X%02d_Y%02d", x, y);      //set the name of the histogram
        if(outFile->Get(cc)){
            scaling_hist[x][y] = (TH1F*)outFile->Get(cc);
        }
        else{
            scaling_hist[x][y] = new TH1F(cc,";ADC channel;counts",200,0,3000);
        }

      }
    }
    
    TH2F* effhitsmap;                                   //2D hits map
    char cc[60];
    memset(cc,0,sizeof(cc));
    sprintf(cc ,"effhitsmap"); 
    if(outFile->Get(cc)){    
        effhitsmap = (TH2F*)outFile->Get(cc);
    }
    else{
        effhitsmap = new TH2F(cc,";X;Y",96,0,96.,96,0,96.);       
    }
  

  char pedestaldata[80] ="./Calibration/noise_03_07_1pC.txt";           //Notice:This pedestal file is NOT the txt file generated by Pedestal.C. It should be generated by other ways
  LoadPedestal(pedestaldata);                             //*****************
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ////mapL2 fec to connector Number
  //std::map <Int_t,Int_t> fecNo;                             //***********
  //fecNo.insert(pair<Int_t,Int_t>(5,0));//fec 1: hirose 0,1 
  //fecNo.insert(pair<Int_t,Int_t>(2,1));//fec 5: hirose 6,7
  //fecNo.insert(pair<Int_t,Int_t>(7,2));//fec 2: hirose 2,3
  //fecNo.insert(pair<Int_t,Int_t>(10,3));//fec 4: hirose 4,5
          
  //new mapL2
  std::map <Int_t, Int_t> mapL2;
  mapL2.insert(pair<Int_t, Int_t>(31, 0));                    //fec 31--->tag 0
  mapL2.insert(pair<Int_t, Int_t>(15, 1));                    //fec 15--->tag 1
  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //Loop start
  cout<<"Loop Root File..."<<endl;
  if (fChain == 0) return;
  Long64_t nentries = fChain->GetEntriesFast();
  cout<<"~~~~~~~~~~~~~~~"<<endl;
  cout<<"Nentries:"<<nentries<<endl;
  Long64_t ientry;
  
  int effhit; 
  double pedM;

  int x_count, y_count;

  double sumA[2];             //sum(maxADC) of x, y
  double sumAP[2];            //sum(maxADC*channel position) of x, y
  double pos[2];              //x, y position reconstructed

  int pos_int[2];              //conveted  x,y position in int format each from 1~96



  //A single loop for hitsmap one event
    for (Long64_t jentry=0; jentry<nentries;jentry++){
        ientry = LoadTree(jentry);
        if (ientry < 0) break;
        fChain->GetEntry(jentry);
        //loop entries
        if(jentry%((int)(nentries/10.))==0){
            // cout<<"Events:"<<jentry<<"("<<(int)(jentry*100./nentries)<<"%)"<<endl;
            cout<<"Events:"<<jentry<<endl;
        }
        ////reset;

        memset(sumA,0,sizeof(sumA));
        memset(sumAP,0,sizeof(sumAP));
        memset(pos,0,sizeof(pos));

        effhit=0;
        x_count = 0;            //to count the x hits number in an event
        y_count = 0;            //to count the y hits number in an event

        //fill 
        for(int i=0; i<nHits;i++){                     //********

            pedM= pedestal[mapL2[Fec[i]]][Chip[i]][Chn[i]][0];                    //mean is the 4th column of pedestal file

            sumADC[i]=sumADC[i]-pedM*Nsp;
            maxADC[i]=maxADC[i]-pedM;
            summaxADC = summaxADC - pedM;                //New! Compute the true summaxADC for each event
                
            // if (Chn[i] == 0 || Chn[i] == 67) continue;              //wrong signal in these two channals
            // if (pixelX[i]==0 && pixelY[i]==0) continue;                 //not a signal channel
            // if(maxPoint[i]>140||maxPoint[i]<100) continue;          //peaking time

            if((Chip[i]==2||Chip[i]==0) && Chn[i]==67) {
                summaxADC = summaxADC-maxADC[i];
                continue;
            }


            //fill the 4 graphs
            if (pixelX[i]!=0) {                         //this is an x hit
                x_count++;
                sumA[0] +=maxADC[i]; 
                sumAP[0] +=maxADC[i]*pixelX[i];

            }
            else if (pixelY[i]!=0) {                    //this is a y hit
                y_count++;
                sumA[1] +=maxADC[i];
                sumAP[1] +=maxADC[i]*pixelY[i];

            }
            else{             //this signal is NOT from a detector channel, drop it
                summaxADC = summaxADC-maxADC[i];
                continue;
            }


            effhit++;
        }//single event 

        //Only select the events with few hits
        if(x_count > 3 || y_count > 3)  continue;        

        //Charge mass center method for position reconstruction, ONLY for Fe55 test
        //fill the hitsmap and central region spectrum
        if(sumA[0]*sumA[1]!=0){
          for(int d=0;d<2;d++){
            pos[d] = sumAP[d]/sumA[d];        //position reconstructionn
          }
          //std::cout<<"posX ="<<pos[0]<<"; posY ="<<pos[1]<<std::endl;
        }
        else continue;

        //convert the <double> position to <int> position
        pos_int[0] = (int)pos[0] + 1;
        pos_int[1] = (int)pos[1] + 1;


        //Fill the summaxADC into the (x,y) histogram
        scaling_hist[pos_int[0]][pos_int[1]]->Fill(summaxADC);
        effhitsmap->Fill(pos_int[0], pos_int[1]);

        

    }//loop end 


    outtxt << "X\t" << "Y\t" << "No. of Entries\t"<< "Convert Factor(keV/ADC channel)\n" << endl;
    for(int x = 0;x < strip_num;x++){
        for(int y = 0;y < strip_num;y++){
            int num = 0;
            num = scaling_hist[x][y]->GetEntries();
            if(num != 0){
                double mean = scaling_hist[x][y]->GetMean();
                double factor = 5.9/mean;                //convert factor
                outtxt << x+1 << "\t" << y+1 << "\t" << num << "\t" << setprecision(8) << factor <<"\n"<< endl;
            }
            else{
                outtxt << x+1 << "\t" << y+1 << "\t" << num << "\t" << "NaN" << "\n" << endl;
            }
        }
    }
    outtxt.close();
    
    outFile->Write();
    outFile->Close();
    
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
}

//define main()
string filename;
void helpinfo(){

  cout<<"Usage is ./Scaling.exe ./Raw2ROOT/<filename>\n";
  cout<<"default output file name is <./Scaling/202xxxxx_scaling.root> and <./Scaling/202xxxxx_scaling.txt>"<<endl;	
  return;
} 
void phrase_command(int argc,char *argv[]){
  if (argc<2){ helpinfo();
    exit(0);
  }else {filename=(string) argv[1]; cout<<"START\n~~~~~*****~~~~~\nInput File : "<<filename<<endl;}
}

int main(int argc,char *argv[])
{

  phrase_command(argc,argv);
  string Tt="richraw";
  const char *TtreeName=(char *)(Tt.data());
  const Text_t* RawRootFile=(Text_t*)(filename.data());
  char *RawRootFile_c=(char *)(filename.data());
  TFile *f = (TFile*)gROOT->GetListOfFiles()->FindObject(RawRootFile);
  if (!f) 
    {
      f = new TFile(RawRootFile_c);
     }
  TTree *tree = (TTree*)gDirectory->Get(TtreeName);
 
  RootConvert xx;
  xx.RootConvert::Init(tree);
  xx.RootConvert::Loop(RawRootFile_c);
    cout<<"\n~~~~~*****~~~~~\nTHE END"<<endl;
  return 1;

} 

